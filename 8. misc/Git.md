# GIT 상황별 용법

## 로컬에서 작업한 것이 있는데 취소하고 원래걸로 돌려야 한다: git restore <file>
작업을 하기 위해 cmd를 켜고 git pull로 인터넷에 올라간 최신 버전을 가져왔다. 지금은 인터넷에 있는 내용과 로컬에 있는 내용이 완전히 같다  
이제 작업을 시작한다. 리팩토링을 위해 원래 있던 어떤 기능을 분리하여 다른 파일에 붙여넣기했다  
하고 보니 잘못된 방향으로 했다는 것을 알아챘다. 방금 있었던 모든 작업을 취소하고 인터넷에 있는 상태로 돌아가려고 한다  
- 작업한 폴더를 지우고 git clone https://~~~.git 하면 되긴 한다. 하지만 별로 좋은 방법은 아니다

목표는 위와 같은 결과가 나오도록 하는 것이다.
> git restore .  
> 작업 트리에서 수정한 파일을 되돌리는 명령어이다  
  

## 특별한 기능을 시험삼아 적용하고 싶은데 원래 상태에 방해가 되지 않게 하고 싶다
- 먼저 새로운 브랱치를 만들어야 한다
    > git branch mytest1
- 새로운 브랜치로 지금 사용할 브랜치를 지정해줘야 한다
    > git checkout mytest1


### 시험 결과가 마음에 들어서 원래의 브랜치에 편입시켜도 문제없이 돌아갈 것이다
- 원래의 브랜치로 HEAD를 되돌린다
    > git checkout master
- 시험을 작성했던 브랜치를 현재위 브랜치(master)에 병합한다
    > git merge mytest1
- master에 병합되었으므로 시험을 진행했던 브랜치는 더이상 필요하지 않다
    > git branch d mytest1


## 자잘한 커밋을 너무 많이 했다. 하나로 모으고 싶다: squash
ref. from [toast](https://meetup.toast.com/posts/39)
자잘한 작업을 하면서 각 단위마다 완성이 되면 commit하고 push하였다. 그러다보니 하루에만 10개의 커밋 로그가 생겼다. 이대로면 커밋 로그가 너무 지저분해지고 중구난방이 될 것 같다.그래서 이를 하나로 모으고 싶다.

- 먼저 커밋 로그를 보며 몇개까지 합칠지 확인한다
    > git log --pretty=oneline
- interactive rebase한다. 맨 처음이 HEAD면 HEAD를 포함한 개수를 ~ 뒤에 적어준다. 10개의 커밋을 하나로 합쳐야 하므로 10을 적어준다
    > git rebase -i HEAD~10
- 그러면 vim 에디터가 나타난다. 맨 위(HEAD)는 pick을 유지하고 나머지 아래 합쳐야 하는 부분은 pick을 squash로 수정한다.
- 수정하고 저장하면 커밋 메세지를 다시 입력하는 vim이 뜬다. 여기서 맨 위에 적는 메시지가 나중에 PR같은거를 할 때 제목으로 사용된다. 그러므로 우래에 주석으로 어떤 커밋메시지인지 적혀있는 부분은 놔두고 맨 위에 제목으로 사용될 커멧 메시지를 적는다.
- 수정하고 저장하면 로컬에서는 커밋 로그가 바뀌어 있다. 이제 이를 push해야 한다. 다만 이 상황은 계속 commit을 하고 push한 상황이기 때문에 로컬과 리모트의 커밋로그가 같지 않다. 따라서 강제로 push하여야 한다.
    > git push -f