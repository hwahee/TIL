# OOP의 원칙: SOLID


## 단일 책임 원칙 Single Responsibility
모듈이 변경되는 이유는 단 한 가지여아 한다

    만약 두 가지 책임을 가지는 경우, 즉 변경될 경우 이유가 관련 없는 두 가지일 경우
    한 가지 책임과 관련된 것을 변경하면
    다른 하나의 기능도 변경될 위험이 크다


## 개방-폐쇄 원칙 Open-Closed
모듈의 확장되는 것은 수월해야 하며 모듈 그 자체는 되도록 변경되지 않아야 한다

    98가지 일반형, 1가지 고급형, 1가지 저급형의 어떤 모듈이 있다고 하자
    고급형과 저급형의 가능을 구현하기 위해 원래의 일반형 모듈의 동작을 조건문을 다는 방식으로 변경하는 것은 비효율적이다. 
    이 경우 위해 일반형 모듈을 확장해서(상속) 고급형과 저급형의 하위 클래스를 만들어 기능을 재정의한다면(override)
    일반형 모듈에 영향을 하나도 미치지 않으면서 특수한 경우를 처리할 수 있게 된다 


## 리스코프 치환 원칙 Liskov Substitution
하위 클래스는 상위 클래스를 대신하여도 아무 문제 없이 작동해야 한다
    
    int형을 받아서 그것을 DB에 저장하는 모듈을 만들었다고 가정하자
    이 모듈을 사용하다가 이제는 string을 받아 그 안에 있는 숫자를 읽을 필요가 생겄다고 했을 때
    모듈을 상속하여 int뿐만 아니라 string을 받을 수 있도록 확장하는 경우
    그 전에 사용했던 부모 모둘이 방금 확장한 모듈을 넣어도 정상적으로 작동할 것이다
    이 경우 상위 클래스를 하위 클래스로 대체하고도 문제가 없기 때문에 원칙이 잘 지켜졌다
          

## 인터페이스 분리 원칙 Interface Segregation
필요한 최소한의 인터페이스만 열려있어야 한다

    만약 고객과 관리자가 함께 사용하는 시스템이 있을 때
    고객이 사용하는 서비스에 필요이상의 인터페이스가 열려있으면
    관리자의 영역까지 침범하여 잘못된 동작을 수행할 수도 있다
    이 경우  하나의 시스템에 존재하는 인터피에스 전체를
    관리자용 인터페이스와 고객용 인터페이스로 나누면 문제를 해결할 수 있다


## 의존성 역전 원칙 Dependency Inversion
상위 계층이 하위 계층에 의존하는 전통적인 의존관계를 역전한다는 의미

구체적인 구현이 아닌 추상화된 것에 의존해야 한다

    이 원칙을 적용하면 추상적인 상위 인터페이스는 구체적인 하위 인터페이스에 독립적인 상태가 된다
    
